# Титульник

# Задания на практику

Цель: Изучить работу алгоритмов поиска и сортировки

Задачи:
- Изучить типы алгоритмов
- Исследовать алгоритм сортировки пузырьком
- Исследовать алгоритм сортировки деревом
- Исследовать алгоритм пирамидальной сортировки
- Исследовать алгоритм Кнута-Морриса-Паратта
- Исследовать алгоритм Боуера-Мура
- Исследовать алгоритм бинарного поиска  

# Оглавление

# Введение

# Теоретическая часть

# Алгоритмы сортировки

## Болотная сортировка (Bogosort) ИИ

Болотная сортировка - это алгоритм сортировки, который случайным образом переставляет элементы массива до тех пор, пока отсортированный массив не получится.

### Логика работы

1. Проверяем, отсортирован ли массив. Если да, то завершаем алгоритм.
2. Иначе перемешиваем элементы массива случайным образом.
3. Проверяем, отсортирован ли массив после перемешивания. Если да, то завершаем алгоритм, иначе повторяем шаги 2-3.

### Плюсы и минусы

Плюсы:
- Простота реализации
- Может быть использован для проверки других алгоритмов сортировки, так как он всегда останавливается, когда массив отсортирован.

Минусы:
- Неэффективен и может работать очень долго для больших массивов.
- Шансы получить отсортированный массив случайным образом крайне малы, поэтому алгоритм не гарантирует быструю сортировку.
- Непредсказуемость времени выполнения.

### Источники
- [Wikipedia](https://en.wikipedia.org/wiki/Bogosort)

Сортировка пузырьком — элементарный алгоритм
сортировки, который сравнивает
и меняет соседние элементы
массива до тех пор, пока все
элементы не будут отсортированы.

### Логика работы

1. Стартуем от первого элемента массива и сравниваем его с его соседом справа.
2. Если первый элемент больше второго, меняем элементы местами.
3. Двигаемся на следующую пару элементов и продолжаем сравнивать и менять местами элементы, если это необходимо.
4. Продолжаем выполнять шаги 1-3 до тех пор, пока все элементы не будут отсортированы в порядке возрастания.

### Плюсы и минусы

Плюсы:
- Простота реализации
- Разумное время работы для небольших массивов

Минусы:
- Очень медленный для больших массивов данных
- Элементы на концах массива могут перемещаться медленно, даже если они уже отсортированы.

### Источники
- [Wikipedia](https://en.wikipedia.org/wiki/Bubble_sort)
- [GeeksforGeeks](https://www.geeksforgeeks.org/bubble-sort/)

## Сортировка деревом (Tree Sort) ИИ

Дерево - это структура данных, которая состоит из корня и ноль или более поддеревьев, каждое из которых также является деревом. Сортировка деревом использует бинарное дерево для сортировки элементов.

### Логика работы

1. Создаем пустое бинарное дерево.
2. Вставляем каждый элемент списка в бинарное дерево.
3. Производим обход дерева (ин-ордер или симметричный обход) и записываем элементы в исходный список в отсортированном порядке.

### Плюсы и минусы

Плюсы
- Сортировка деревом имеет линейную сложность O(nlogn).
- Эффективна для сортировки больших массивов данных.
- Не требует дополнительного пространства, кроме дополнительного пространства, необходимого для создания дерева.

Минусы

- Может быть неэффективна для небольших массивов данных.
- Для сбалансированного бинарного дерева эффективность алгоритма будет лучше, однако создание сбалансированного дерева может быть сложным и занимать больше времени.
- Относительно более сложный алгоритм, чем, например, Bubble Sort или Selection Sort.

### Источники

- Cormen, T.H., Leiserson, C.E., Rivest, R.L., & Stein, C. (2009). Introduction to Algorithms (3rd ed.). MIT Press.
- GeeksforGeeks. (2021). Tree Sort. Retrieved June 19, 2021, from https://www.geeksforgeeks.org/tree-sort/

## Пирамидальная сортировка ИИ

Пирамидальная сортировка - это алгоритм сортировки данных, который использует структуру данных в виде пирамиды, чтобы эффективно находить наибольшее (или наименьшее) значение массива/списка и переставлять его в начало (или конец) списка. 

### Логика работы
1. Построение двоичной кучи из исходного массива данных. Таким образом, мы получаем структуру данных, где для каждого узла выполняется условие $a[i]<=a[2*i] \&\& a[i]<=a[2*i+1]$ (для сортировки по возрастанию, либо наоборот: для сортировки по убыванию)
2. Максимальный элемент в корне кучи. Меняем местами корневой элемент с последним справа в подмассиве.
3. Сокращение диапазона массива на 1, исключая отсортированные элементы, и перестройка кучи (свап корневой вершины с наибольшим из листьев поддерева). Поэтому возникает необходимость восстановления структуры пирамиды (Heapify).
4. Повторяем шаги 2-3, пока диапазон не станет 1.

### Плюсы и минусы

Плюсы:
- Эффективен на больших массивах, так как время выполнения составляет $O(n log n)$.
- Имеет инструкцию по построению двоичной кучи, что приводит к дополнительному применению на практике.

Минусы:
- Из-за высокой константы времени выполнения, алгоритм может работать медленнее простых алгоритмов сортировки (например, сортировка вставками) для небольших массивов.
- Нет возможности параллельной обработки данных, так как каждый шаг зависит от предыдущего.

### Источники
- Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2009). Introduction to algorithms. MIT press.
- https://www.geeksforgeeks.org/heap-sort/



# Алгоритмы поиска

## Алгоритм Кнута-Морриса-Паратта (KMП) ИИ

КМП - это алгоритм поиска подстроки в строке, который был разработан Кнутом, Моррисом и Праттом в 1977 году. Этот алгоритм используется для поиска всех вхождений подстроки в строку и работает за время O(n + m), где n - длина строки, а m - длина подстроки.

### Логика работы

1. Строим массив префиксных значений (prefix function) для заданной подстроки.
2. Сравниваем символы в строке и подстроке, начиная с начала.
3. Если символы совпадают, то индексы обоих смещаются на следующий символ в строке и подстроке соответственно.
4. Если символы не совпадают, то мы используем prefix function, чтобы определить максимальное совпадающее префиксное значение подстроки, которое находится внутри текущего несовпадающего префикса подстроки.
5. Мы сдвигаем подстроку на это значение и продолжаем поиски с шага 2.

### Плюсы и минусы

Плюсы:
1. Он является одним из самых быстрых алгоритмов поиска подстроки в строке.
2. Не использует дополнительную память для поиска, кроме массива префиксных значений.
3. Хорошо работает со всеми типами символов (цифрами, буквами, специальными символами).

Минусы:
1. Требует предобработки подстроки для создания массива префиксных значений.
2. Этот алгоритм может быть немного сложным для понимания и реализации.

### Источники

1. Источник: Кнут, Дональд Э. (1977), "Fast Pattern Matching in Strings", SIAM Journal on Computing, 6 (2): 323–350
2. Источник: Кормен, Томас Х. (2009), Introduction to Algorithms (3rd ed.), MIT Press and McGraw-Hill, стр. 923–925.

## Алгоритм Боуера-Мура (БМ) ИИ

BM-алгоритм, который был разработан в 1977 году Р. Боуером и Д. Муром, является алгоритмом поиска подстроки в строке. Он основан на использовании набора матриц, которые позволяют эффективно искать совпадения между подстрокой и строкой. 

### Логика работы

1. Создание таблицы смещений символов: в таблице для каждого символа определяется его смещение от последнего вхождения этого символа в подстроку (если встречается впервые, то считается, что он отсутствует полностью).

2. Сравнение строк: строки сравниваются справа налево, начиная с последнего символа. Определяется шаг смещения в зависимости от совпадений символов подстроки и строки. 

3. Поиск: если найдено совпадение, то производится начало строки (подстроки). 

### Плюсы и минусы

Плюсы:
1. BM-алгоритм является одним из самых эффективных алгоритмов поиска подстроки в строке.

2. Алгоритм не перебирает все возможные варианты, а сразу проверяет только несколько вариантов, что позволяет сократить время выполнения.

3. В отличие от некоторых других алгоритмов, BM-алгоритм работает оптимально на данных случайного доступа.

Минусы:
1. BM-алгоритм не может быть использован в случаях, когда искомая подстрока исчерпывает всю входную строку. 

2. Алгоритм может работать неэффективно, если строка содержит много повторяющихся символов.

3. В случае, если подстрока преимущественно состоит из одного символа, то BM-алгоритм может работать неэффективно.

### Источники

1. Дональд Кнут, «Искусство программирования. Том 3: Сортировка и поиск», Вильямс, 2011.

2. Роберт Седжвик. Алгоритмы на Java. М.: «Издательский дом Вильямс», 2006. 

3. Р. Боуер, Д. Мур. «A New Algorithm for String Search». Communications of the ACM, 20(10): p. 762–772, October 1977.

## Алгоритм поиска в глубину (DFS)

Алгоритм поиска в глубину используется для обхода графа или дерева. Алгоритм начинает обход из заданной вершины и продолжает обход в глубину пока есть не посещенные вершины, затем возвращается назад к предыдущей вершине и продолжает так до тех пор, пока все вершины не будут посещены.

### Логика работы 
1. Создаем переменную, которая будет хранить информацию о посещенных вершинах. В начале все вершины помечаются как непосещенные.
2. Выбираем начальную вершину и помечаем ее как посещенную.
3. Для каждой смежной вершины, которая еще не была посещена, запускаем рекурсивную функцию поиска в глубину.
4. После обхода всех смежных вершин возвращаемся к предыдущей вершине и продолжаем поиск.

### Плюсы и минусы
Плюсы:
- Простой в реализации и понимании
- Эффективен для обхода графов и деревьев с большой глубиной
- Может быть использован для решения задач на поиск пути, маршрута, связности и т.д.

Минусы:
- В худшем случае может иметь экспоненциальную сложность
- Работает только для графов и деревьев без циклов, так как при наличии циклов возможно зацикливание

### Источники
- Introduction to Algorithms, Cormen, Leiserson, Rivest, Stein
- GeeksforGeeks: Depth First Search or DFS for a Graph

Бинарный поиск - алгоритм поиска
элемента в отсортированном массиве
путем деления массива на две половины
и последовательного сужения интервала,
в котором может находиться искомый элемент,
до тех пор, пока искомый элемент не
будет найден или пока не станет ясно, что элемента в массиве нет. 

### Логика работы
1. Установка границ массива (левая и правая границы);
2. Определение середины массива и индекса серединного элемента;
3. Сравнение искомого элемента с серединным элементом;
4. Если искомый элемент равен серединному, возвращаем индекс серединного элемента;
5. Если искомый элемент меньше серединного, то искать в левой половине массива;
6. Если искомый элемент больше серединного, то искать в правой половине массива;
7. Ограничение границ массива до найденной половины;
8. Повторение операций с 2-го пункта до того момента, пока не будет найден искомый элемент или длина интервала поиска не станет равной нулю.

### Плюсы и минусы
Плюсы:
- Бинарный поиск имеет асимптотическую сложность O(log n), что позволяет находить элемент в больших массивах в разы быстрее, чем линейный поиск;
- Алгоритм подходит для поиска как одного элемента, так и нескольких элементов с использованием нескольких запросов.

Минусы:
- Для работы алгоритма необходим отсортированный массив;
- Алгоритм не может быть использован для поиска элементов в связанных списках;
- Бинарный поиск занимает больше памяти, чем линейный поиск, так как необходимо сохранить серединный индекс и границы массива при каждом проходе.

### Источники
- Кормен, Томас X., Лейзерсон, Чарльз И., Ривест, Рональд Л., Штайн, Клиффорд. Алгоритмы: построение и анализ. – М.: Вильямс, 2005. – 1296 с.



# Практическая часть

## Сравнение алгоритмов сортировки

## Сравнение работы алгоритмов поиска

# Заключение
После завершения учебной практики и выполнения работ, я выполнил следующие задачи:
- Изучил понятие «вычислительная сложность», познакомился с
  несколькими примерами наглядно выражающие понятие
  вычислительная сложность, познакомились с понятием
  «О большое» и его классами сложностей.
  
- Изучил алгоритмы сортировки пузырьком, деревом и пирамидальной сортировки
- Изучил алгоритмы поиска Кнута-Морриса-Паратта, Боуера-Мура и алгоритм бинарного поиска 



# Список источников

# Приложения
1. https://habr.com/ru/post/111449/
2. https://proglib.io/p/6-search-algorithms-java
3. https://medium.com/nuances-of-programming/алгоритмы-поиска-которые-должен-знать-каждый-специалист-по-обработке-и-анализу-данных-8ffb944850cc

## Ссылка на реп отчета

## Отчет на антиплагиат


<style>
    body > * {
        /* color: red */
        color: black;
        font: 14px 'Times New Roman'
    }

    /* h1 {
        border-bottom: red
    } */

    hr {
        border: red solid;
        /* display: none; */
    }

</style>